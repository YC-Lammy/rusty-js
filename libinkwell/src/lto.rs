# ! [doc = " Abstract link time optimization."] # ! [doc = ""] # ! [doc = " ## ThinLTO"] # ! [doc = ""] # ! [doc = " ThinLTO is designed to do LTO while requiring fewer resources than regular"] # ! [doc = " LTO. It can run much faster and in less memory (comparable to linking"] # ! [doc = " without LTO) than regular LTO, with essentially no loss in optimization."] # ! [allow (non_camel_case_types)] pub use llvm_sys :: lto :: * ; # [no_mangle] pub unsafe extern "C" fn lto_get_version () -> * const :: libc :: c_char { llvm_sys :: lto :: lto_get_version () } # [no_mangle] pub unsafe extern "C" fn lto_get_error_message () -> * const :: libc :: c_char { llvm_sys :: lto :: lto_get_error_message () } # [no_mangle] pub unsafe extern "C" fn lto_module_is_object_file (path : * const :: libc :: c_char) -> lto_bool_t { llvm_sys :: lto :: lto_module_is_object_file (path) } # [no_mangle] pub unsafe extern "C" fn lto_module_is_object_file_for_target (path : * const :: libc :: c_char , target_triple_prefix : * const :: libc :: c_char ,) -> lto_bool_t { llvm_sys :: lto :: lto_module_is_object_file_for_target (path , target_triple_prefix) } # [doc = " Return true if `Buffer` contains a bitcode file with ObjC code"] # [doc = " (category or class) in it."] # [no_mangle] pub unsafe extern "C" fn lto_module_has_objc_category (mem : * const :: libc :: c_void , length : :: libc :: size_t ,) -> lto_bool_t { llvm_sys :: lto :: lto_module_has_objc_category (mem , length) } # [doc = " Checks if a buffer is a loadable object file."] # [no_mangle] pub unsafe extern "C" fn lto_module_is_object_file_in_memory (mem : * const :: libc :: c_void , length : :: libc :: size_t ,) -> lto_bool_t { llvm_sys :: lto :: lto_module_is_object_file_in_memory (mem , length) } # [no_mangle] pub unsafe extern "C" fn lto_module_is_object_file_in_memory_for_target (mem : * const :: libc :: c_void , length : :: libc :: size_t , target_triple_prefix : * const :: libc :: c_char ,) -> lto_bool_t { llvm_sys :: lto :: lto_module_is_object_file_in_memory_for_target (mem , length , target_triple_prefix) } # [no_mangle] pub unsafe extern "C" fn lto_module_create (path : * const :: libc :: c_char) -> lto_module_t { llvm_sys :: lto :: lto_module_create (path) } # [no_mangle] pub unsafe extern "C" fn lto_module_create_from_memory (mem : * const :: libc :: c_void , length : :: libc :: size_t ,) -> lto_module_t { llvm_sys :: lto :: lto_module_create_from_memory (mem , length) } # [no_mangle] pub unsafe extern "C" fn lto_module_create_from_memory_with_path (mem : * const :: libc :: c_void , length : :: libc :: size_t , path : * const :: libc :: c_char ,) -> lto_module_t { llvm_sys :: lto :: lto_module_create_from_memory_with_path (mem , length , path) } # [no_mangle] pub unsafe extern "C" fn lto_module_create_in_local_context (mem : * const :: libc :: c_void , length : :: libc :: size_t , path : * const :: libc :: c_char ,) -> lto_module_t { llvm_sys :: lto :: lto_module_create_in_local_context (mem , length , path) } # [no_mangle] pub unsafe extern "C" fn lto_module_create_in_codegen_context (mem : * const :: libc :: c_void , length : :: libc :: size_t , path : * const :: libc :: c_char , cg : lto_code_gen_t ,) -> lto_module_t { llvm_sys :: lto :: lto_module_create_in_codegen_context (mem , length , path , cg) } # [no_mangle] pub unsafe extern "C" fn lto_module_create_from_fd (fd : :: libc :: c_int , path : * const :: libc :: c_char , file_size : :: libc :: size_t ,) -> lto_module_t { llvm_sys :: lto :: lto_module_create_from_fd (fd , path , file_size) } # [no_mangle] pub unsafe extern "C" fn lto_module_create_from_fd_at_offset (fd : :: libc :: c_int , path : * const :: libc :: c_char , file_size : :: libc :: size_t , map_size : :: libc :: size_t , offset : :: libc :: off_t ,) -> lto_module_t { llvm_sys :: lto :: lto_module_create_from_fd_at_offset (fd , path , file_size , map_size , offset) } # [no_mangle] pub unsafe extern "C" fn lto_module_dispose (_mod : lto_module_t) { llvm_sys :: lto :: lto_module_dispose (_mod) } # [no_mangle] pub unsafe extern "C" fn lto_module_get_target_triple (_mod : lto_module_t) -> * const :: libc :: c_char { llvm_sys :: lto :: lto_module_get_target_triple (_mod) } # [no_mangle] pub unsafe extern "C" fn lto_module_set_target_triple (_mod : lto_module_t , triple : * const :: libc :: c_char ,) { llvm_sys :: lto :: lto_module_set_target_triple (_mod , triple) } # [no_mangle] pub unsafe extern "C" fn lto_module_get_num_symbols (_mod : lto_module_t) -> :: libc :: c_uint { llvm_sys :: lto :: lto_module_get_num_symbols (_mod) } # [no_mangle] pub unsafe extern "C" fn lto_module_get_symbol_name (_mod : lto_module_t , index : :: libc :: c_uint ,) -> * const :: libc :: c_char { llvm_sys :: lto :: lto_module_get_symbol_name (_mod , index) } # [no_mangle] pub unsafe extern "C" fn lto_module_get_symbol_attribute (_mod : lto_module_t , index : :: libc :: c_uint ,) -> lto_symbol_attributes { llvm_sys :: lto :: lto_module_get_symbol_attribute (_mod , index) } # [doc = " Returns the module's linker options."] # [doc = ""] # [doc = " The linker options may consist of multiple flags. It is the linker's"] # [doc = " responsibility to split the flags using a platform-specific mechanism."] # [doc = ""] # [doc = " Added in LLVM 3.7."] # [no_mangle] pub unsafe extern "C" fn lto_module_get_linkeropts (_mod : lto_module_t) -> * const :: libc :: c_char { llvm_sys :: lto :: lto_module_get_linkeropts (_mod) } # [no_mangle] pub unsafe extern "C" fn lto_module_get_macho_cputype (_mod : lto_module_t , out_cputype : * mut :: libc :: c_uint , out_cpusubtype : * mut :: libc :: c_uint ,) -> lto_bool_t { llvm_sys :: lto :: lto_module_get_macho_cputype (_mod , out_cputype , out_cpusubtype) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_diagnostic_handler (arg1 : lto_code_gen_t , arg2 : lto_diagnostic_handler_t , arg3 : * mut :: libc :: c_void ,) { llvm_sys :: lto :: lto_codegen_set_diagnostic_handler (arg1 , arg2 , arg3) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_create () -> lto_code_gen_t { llvm_sys :: lto :: lto_codegen_create () } # [no_mangle] pub unsafe extern "C" fn lto_codegen_create_in_local_context () -> lto_code_gen_t { llvm_sys :: lto :: lto_codegen_create_in_local_context () } # [no_mangle] pub unsafe extern "C" fn lto_codegen_dispose (arg1 : lto_code_gen_t) { llvm_sys :: lto :: lto_codegen_dispose (arg1) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_add_module (cg : lto_code_gen_t , _mod : lto_module_t ,) -> lto_bool_t { llvm_sys :: lto :: lto_codegen_add_module (cg , _mod) } # [doc = " Sets the object module for code gneeration. This will transfer ownership"] # [doc = " of the module to the code generator."] # [doc = ""] # [doc = " Added in LLVM 3.7."] # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_module (cg : lto_code_gen_t , _mod : lto_module_t) { llvm_sys :: lto :: lto_codegen_set_module (cg , _mod) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_debug_model (cg : lto_code_gen_t , arg1 : lto_debug_model ,) -> lto_bool_t { llvm_sys :: lto :: lto_codegen_set_debug_model (cg , arg1) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_pic_model (cg : lto_code_gen_t , arg1 : lto_codegen_model ,) -> lto_bool_t { llvm_sys :: lto :: lto_codegen_set_pic_model (cg , arg1) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_cpu (cg : lto_code_gen_t , cpu : * const :: libc :: c_char) { llvm_sys :: lto :: lto_codegen_set_cpu (cg , cpu) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_assembler_path (cg : lto_code_gen_t , path : * const :: libc :: c_char ,) { llvm_sys :: lto :: lto_codegen_set_assembler_path (cg , path) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_assembler_args (cg : lto_code_gen_t , args : * mut * const :: libc :: c_char , nargs : :: libc :: c_int ,) { llvm_sys :: lto :: lto_codegen_set_assembler_args (cg , args , nargs) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_add_must_preserve_symbol (cg : lto_code_gen_t , symbol : * const :: libc :: c_char ,) { llvm_sys :: lto :: lto_codegen_add_must_preserve_symbol (cg , symbol) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_write_merged_modules (cg : lto_code_gen_t , path : * const :: libc :: c_char ,) -> lto_bool_t { llvm_sys :: lto :: lto_codegen_write_merged_modules (cg , path) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_compile (cg : lto_code_gen_t , length : * mut :: libc :: size_t ,) -> * const :: libc :: c_void { llvm_sys :: lto :: lto_codegen_compile (cg , length) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_compile_to_file (cg : lto_code_gen_t , name : * mut * const :: libc :: c_char ,) -> lto_bool_t { llvm_sys :: lto :: lto_codegen_compile_to_file (cg , name) } # [doc = " Runs optimization for the merged module."] # [doc = ""] # [doc = " Returns true on error."] # [doc = ""] # [doc = " Added in LLVM 3.7."] # [no_mangle] pub unsafe extern "C" fn lto_codegen_optimize (cg : lto_code_gen_t) -> lto_bool_t { llvm_sys :: lto :: lto_codegen_optimize (cg) } # [doc = " Generates code for the optimized merged module into one native object file."] # [doc = ""] # [doc = " Does not run IR optimizations on the merged module."] # [doc = ""] # [doc = " Returns a pointer to the generated mach-o/ELF buffer with length"] # [doc = " set to the buffer size. This buffer is owned by `cg` and will be"] # [doc = " freed when `lto_codegen_dispose` is called or `lto_codegen_compile_optimized`"] # [doc = " is called again. Returns null on failure."] # [doc = ""] # [doc = " Added in LLVM 3.7."] # [no_mangle] pub unsafe extern "C" fn lto_codegen_compile_optimized (cg : lto_code_gen_t , length : * mut :: libc :: size_t ,) -> * mut :: libc :: c_void { llvm_sys :: lto :: lto_codegen_compile_optimized (cg , length) } # [doc = " Returns the runtime API version."] # [doc = ""] # [doc = " Added in LLVM 3.7."] # [no_mangle] pub unsafe extern "C" fn lto_api_version () -> :: libc :: c_uint { llvm_sys :: lto :: lto_api_version () } # [no_mangle] pub unsafe extern "C" fn lto_set_debug_options (options : * mut * const :: libc :: c_char , number : :: libc :: c_int ,) { llvm_sys :: lto :: lto_set_debug_options (options , number) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_debug_options (cg : lto_code_gen_t , arg1 : * const :: libc :: c_char ,) { llvm_sys :: lto :: lto_codegen_debug_options (cg , arg1) } # [no_mangle] pub unsafe extern "C" fn lto_codegen_debug_options_array (cg : lto_code_gen_t , arg2 : * const * const :: libc :: c_char , number : :: libc :: c_int ,) { llvm_sys :: lto :: lto_codegen_debug_options_array (cg , arg2 , number) } # [no_mangle] pub unsafe extern "C" fn lto_initialize_disassembler () { llvm_sys :: lto :: lto_initialize_disassembler () } # [doc = " Sets if we should run the internalize pass during optimization and code generation."] # [doc = ""] # [doc = " Added in LLVM 3.7."] # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_should_internalize (cg : lto_code_gen_t , ShouldInternalize : lto_bool_t ,) { llvm_sys :: lto :: lto_codegen_set_should_internalize (cg , ShouldInternalize) } # [doc = " Set whether to embed uselists in bitcode."] # [doc = ""] # [doc = " Sets whether `lto_codegen_write_merged_modules` should embed uselists in"] # [doc = " output bitcode. This should be turned on for all -save-temps output."] # [doc = ""] # [doc = " Added in LLVM 3.7."] # [no_mangle] pub unsafe extern "C" fn lto_codegen_set_should_embed_uselists (cg : lto_code_gen_t , ShouldEmbedUselists : lto_bool_t ,) { llvm_sys :: lto :: lto_codegen_set_should_embed_uselists (cg , ShouldEmbedUselists) } # [doc = " Instantiates a ThinLTO code generator."] # [doc = ""] # [doc = " Returns null on error (check `lto_get_error_message` for details)."] # [doc = ""] # [doc = " The code generator should not be reused."] # [no_mangle] pub unsafe extern "C" fn thinlto_create_codegen () -> thinlto_code_gen_t { llvm_sys :: lto :: thinlto_create_codegen () } # [doc = " Frees a code generator."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_dispose (cg : thinlto_code_gen_t) { llvm_sys :: lto :: thinlto_codegen_dispose (cg) } # [doc = " Add a module to a code generator."] # [doc = ""] # [doc = " Identifier must be unique among all the modules in the code generator."] # [doc = " The data buffer remains owned by the client, and must live at least"] # [doc = " as long as the code generator."] # [doc = ""] # [doc = " Returns null on failure."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_add_module (cg : thinlto_code_gen_t , identifier : * const :: libc :: c_char , data : * const :: libc :: c_char , length : :: libc :: c_int ,) { llvm_sys :: lto :: thinlto_codegen_add_module (cg , identifier , data , length) } # [doc = " Optimize and codegen all modules attached to the code generator."] # [doc = ""] # [doc = " Resulting objects are accessible with `thinlto_module_get_object`."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_process (cg : thinlto_code_gen_t) { llvm_sys :: lto :: thinlto_codegen_process (cg) } # [doc = " Return the number of object files produced by the code generator."] # [doc = ""] # [doc = " This usually matches the number of input files, but is not guaranteed"] # [doc = " to."] # [no_mangle] pub unsafe extern "C" fn thinlto_module_get_num_objects (cg : thinlto_code_gen_t) -> :: libc :: c_int { llvm_sys :: lto :: thinlto_module_get_num_objects (cg) } # [doc = " Return a reference to the `index`th object file produced by the"] # [doc = " code generator."] # [no_mangle] pub unsafe extern "C" fn thinlto_module_get_object (cg : thinlto_code_gen_t , index : :: libc :: c_uint ,) -> LTOObjectBuffer { llvm_sys :: lto :: thinlto_module_get_object (cg , index) } # [doc = " Return the number of object files produced by the code generator."] # [doc = ""] # [doc = " Usually the same as the number of input files, but not guaranteed."] # [no_mangle] pub unsafe extern "C" fn thinlto_module_get_num_object_files (cg : thinlto_code_gen_t ,) -> :: libc :: c_uint { llvm_sys :: lto :: thinlto_module_get_num_object_files (cg) } # [doc = " Return the path to the ith output object file."] # [doc = ""] # [doc = " Use `thinlto_module_get_num_object_files` to get the number of available objects."] # [no_mangle] pub unsafe extern "C" fn thinlto_module_get_object_file (cg : thinlto_code_gen_t , index : :: libc :: c_uint ,) -> * const :: libc :: c_char { llvm_sys :: lto :: thinlto_module_get_object_file (cg , index) } # [doc = " Set which PIC code model to generate."] # [doc = ""] # [doc = " Returns true on error."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_pic_model (cg : thinlto_code_gen_t , model : lto_codegen_model ,) -> lto_bool_t { llvm_sys :: lto :: thinlto_codegen_set_pic_model (cg , model) } # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_cache_dir (cg : thinlto_code_gen_t , cache_dir : * const :: libc :: c_char ,) { llvm_sys :: lto :: thinlto_codegen_set_cache_dir (cg , cache_dir) } # [doc = " Set the cache pruning interval, in seconds."] # [doc = ""] # [doc = " A negative value disables pruning, and 0 will force pruning to occur."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_cache_pruning_interval (cg : thinlto_code_gen_t , interval : :: libc :: c_int ,) { llvm_sys :: lto :: thinlto_codegen_set_cache_pruning_interval (cg , interval) } # [doc = " Set the maximum cache size to persist across builds."] # [doc = ""] # [doc = " This is expressed as a percentage of available disk space. 100 means no limit,"] # [doc = " and 50 means no more than half of the available disk space. 0 is ignored, and"] # [doc = " values over 100 will be reduced to 100."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_final_cache_size_relative_to_available_space (cg : thinlto_code_gen_t , percentage : :: libc :: c_uint ,) { llvm_sys :: lto :: thinlto_codegen_set_final_cache_size_relative_to_available_space (cg , percentage) } # [doc = " Set the expiration (in seconds) for cache entries."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_cache_entry_expiration (cg : thinlto_code_gen_t , expiration : :: libc :: c_uint ,) { llvm_sys :: lto :: thinlto_codegen_set_cache_entry_expiration (cg , expiration) } # [doc = " Set the maximum size of the cache directory (in bytes). A value over the"] # [doc = " amount of available space on the disk will be reduced to the amount of"] # [doc = " available space. An unspecified default value will be applied. A value of 0"] # [doc = " will be ignored."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_cache_size_bytes (cg : thinlto_code_gen_t , max_size_bytes : :: libc :: c_uint ,) { llvm_sys :: lto :: thinlto_codegen_set_cache_size_bytes (cg , max_size_bytes) } # [doc = " Same as thinlto_codegen_set_cache_size_bytes, except the maximum size is in"] # [doc = " megabytes (2^20 bytes)."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_cache_size_megabytes (cg : thinlto_code_gen_t , max_size_megabytes : :: libc :: c_uint ,) { llvm_sys :: lto :: thinlto_codegen_set_cache_size_megabytes (cg , max_size_megabytes) } # [doc = " Sets the maximum number of files in the cache directory. An unspecified default value will be applied. A value of 0 will be ignored."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_cache_size_files (cg : thinlto_code_gen_t , max_size_files : :: libc :: c_uint ,) { llvm_sys :: lto :: thinlto_codegen_set_cache_size_files (cg , max_size_files) } # [doc = " Create an LTO input file from a buffer."] # [no_mangle] pub unsafe extern "C" fn lto_input_create (buffer : * const :: libc :: c_void , buffer_size : :: libc :: size_t , path : * const :: libc :: c_char ,) -> lto_input_t { llvm_sys :: lto :: lto_input_create (buffer , buffer_size , path) } # [doc = " Free all memory allocated by the input file."] # [no_mangle] pub unsafe extern "C" fn lto_input_dispose (input : lto_input_t) { llvm_sys :: lto :: lto_input_dispose (input) } # [doc = " Get the number of dependent library specifiers for the given input."] # [no_mangle] pub unsafe extern "C" fn lto_input_get_num_dependent_libraries (input : lto_input_t ,) -> :: libc :: c_uint { llvm_sys :: lto :: lto_input_get_num_dependent_libraries (input) } # [doc = " Get the `i`th dependent library specifier for the given input file."] # [doc = ""] # [doc = " The returned string is not null-terminated."] # [no_mangle] pub unsafe extern "C" fn lto_input_get_dependent_library (input : lto_input_t , index : :: libc :: size_t , size : * mut :: libc :: size_t ,) -> * const :: libc :: c_char { llvm_sys :: lto :: lto_input_get_dependent_library (input , index , size) } # [doc = " Return the list of libcall symbols that can be generated by LTO"] # [doc = " that might not be visible from the symbol table of bitcode files."] # [no_mangle] pub unsafe extern "C" fn lto_runtime_lib_symbols_list (size : * mut usize ,) -> * const * const :: libc :: c_char { llvm_sys :: lto :: lto_runtime_lib_symbols_list (size) } # [doc = " Set the path to a directory to use as temporary bitcode storage."] # [doc = ""] # [doc = " This is meant to make the bitcode files available for debugging."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_savetemps_dir (cg : thinlto_code_gen_t , save_temps_dir : * const :: libc :: c_char ,) { llvm_sys :: lto :: thinlto_codegen_set_savetemps_dir (cg , save_temps_dir) } # [doc = " Set the path to a directory to save generated object files."] # [doc = ""] # [doc = " Set this to request on-disk rather than in-memory buffers. When set, use"] # [doc = " `thinlto_module_get_object_file` instead of `thinlto_module_get_object`."] # [no_mangle] pub unsafe extern "C" fn thinlto_set_generated_objects_dir (cg : thinlto_code_gen_t , save_temps_dir : * const :: libc :: c_char ,) { llvm_sys :: lto :: thinlto_set_generated_objects_dir (cg , save_temps_dir) } # [doc = " Set the CPU to generate code for."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_cpu (cg : thinlto_code_gen_t , cpu : * const :: libc :: c_char ,) { llvm_sys :: lto :: thinlto_codegen_set_cpu (cg , cpu) } # [doc = " Disable code generation (running all stages until codegen)."] # [doc = ""] # [doc = " The output with codegen disabled is bitcode."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_disable_codegen (cg : thinlto_code_gen_t , disable : lto_bool_t ,) { llvm_sys :: lto :: thinlto_codegen_disable_codegen (cg , disable) } # [doc = " Perform codegen only{} disable all other stages."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_set_codegen_only (cg : thinlto_code_gen_t , codegen_only : lto_bool_t ,) { llvm_sys :: lto :: thinlto_codegen_set_codegen_only (cg , codegen_only) } # [doc = " Parse -mllvm style debug options."] # [no_mangle] pub unsafe extern "C" fn thinlto_debug_options (options : * const * const :: libc :: c_char , number : :: libc :: c_int ,) { llvm_sys :: lto :: thinlto_debug_options (options , number) } # [doc = " Test if a module has ThinLTO linking support."] # [no_mangle] pub unsafe extern "C" fn lto_module_is_thinlto (module : lto_module_t) -> lto_bool_t { llvm_sys :: lto :: lto_module_is_thinlto (module) } # [doc = " Add a symbol to the list of global symbols that must exist in the"] # [doc = " final generated code."] # [doc = ""] # [doc = " Functions not listed may be inlined in every usage and optimized away."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_add_must_preserve_symbol (cg : thinlto_code_gen_t , name : * const :: libc :: c_char , length : :: libc :: c_int ,) { llvm_sys :: lto :: thinlto_codegen_add_must_preserve_symbol (cg , name , length) } # [doc = " Add a symbol to the list of global symbols that are cross-referenced"] # [doc = " between ThinLTO files."] # [doc = ""] # [doc = " Symbols listed can be discarded if every reference from a ThinLTO module"] # [doc = " to a symbol is optimized away, then the symbol can be discarded."] # [no_mangle] pub unsafe extern "C" fn thinlto_codegen_add_cross_referenced_symbol (cg : thinlto_code_gen_t , name : * const :: libc :: c_char , length : :: libc :: c_int ,) { llvm_sys :: lto :: thinlto_codegen_add_cross_referenced_symbol (cg , name , length) }